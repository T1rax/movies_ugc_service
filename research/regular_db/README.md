# Выбор хранилища для постоянного хранения данных

В прошлой итерации мы уже выбрали MongoDB по нескольким причинам:
- Быстрый
- Легко масштабируемый
- Интересная технология, в которой хотелось попрактиковаться
- Удобный формат хранения данных
- Нет необходимости джойнить данные между "таблицами"

Поэтому текущую задачу для исследования можно сформировать как: "Подходит ли выбранное ранее хранилище для новых требований по быстродействию?"

## Моменты, на которые нужно обратить внимание
- Важнее скорость чтения по отношению к скорости записи
- Как сложно будет его внедрить/доработать для нужного уровня
- Возможно ли в нем реализовать нужные продуктовые кейсы?

# Тестирование

## Описание процесса тестирования
Тестирование будет проводиться на примере оценок к фильмам. Предполагается, что данных такого типа будет больше всего.
Пример одно документа можно увидеть ниже:
```
{
    _id: ObjectId('some_integer_id'),
    user_id: 'user_uuid',
    film_id: 'film_uuid',
    score: 10,
}
```
Всего будет 10 миллионов документов такого типа, все хранятся в одной коллекции.
10 миллионов получаются из:
- 1 млн пользователей
- 100 тыс фильмов
- Не предполагается, что каждый пользователь поставит каждому фильму оценку. Поэтому предположим, что каждый пользователь может оценить от 0 до 20 фильмов в случайном порядке.

Будем тестировать следующие кейсы:
- Сама запись данных
- Вернуть фильмы, которые оценил пользователь с фильтром
- Агрегация средней оценки фильма

Для усреднения оценки тесты будут запускаться несколько раз и вычислять средний результат

## Инструкции по запуску тестирования
- Поднять контейнеры с БД `docker-compose -f research/regular_db/docker-compose.yml up --build`
- Поднять виртуальное окружение
- Запустить скрипт `python3 research/regular_db/scripts/data_loader.py`

## Результаты тестирования
Полученные результаты (Средняя скорость):
- Записи - 2.53 мс
- Список фильмов, которые оценил пользователь с фильтром - 0.08 мс
- Средняя оценка фильма - 177 мс

# Вывод
Выбранный инструмент - MongoDB полностью удовлетворяет нашим требованиям, поэтому его и будем дальше использовать в проекте.